<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>
			LCUI &#8250; 动态 &#8250; 开发日志
		</title>
		<link rel="icon" href="lc-soft.png" type="image/png">
		<meta name="keywords" content="GUI,LCSoft,LCDT,LCUI,Embedded,linux,liuchao,opensource,freesoft,C">
		<meta name="description" content="LCUI 0.13.0 开发日志">
		<meta name="robots" content="all">
		<meta name="author" content="LC-Soft">
		<link type="text/css" rel="stylesheet" href="../files/css/main.css">
		<link type="text/css" rel="stylesheet" href="../files/css/dev_log.css">
	</head>
	<body style="margin-top: 100px;" class="my_body">
		<script type="text/javascript" src="../files/js/jquery-1.8.1.min.js">
		</script>
		<script type="text/javascript" src="../files/js/ms-script.jsx">
		</script>
		<script type="text/javascript" src="../files/js/menu-effect.js">
		</script>
		<script type="text/javascript" src="../files/js/titlemenu.zh-cn.js">
		</script>
		<script type="text/javascript" src="../files/audiojs/float_musicplayer.js">
		</script>
		<div style="padding-top: 30px;">
			<!-- 上面是标题栏区域 -->
			<div class="entry-content">
				<center> <h1> LCUI 0.13.0 </h1> </center>
				<hr>
				<h2> 2012-12-17 </h2>
				<p>LCUI 0.12.6有点赶脚，发布这个版本后，感觉自己自由了，歇息了几天。</p>
				<p>现在先写下这次版本更新中需要实现的东西：<br>
				能够够直接读取图片的信息，之前的版本，都是先读取图片数据，再从图片数据中获取图片信息。<br>
				实现部件的圆角边框绘制，阴影绘制。<br>
				文本框添加占位符功能，文本框为空并未处于焦点状态时，显示占位符。<br>
				图形处理上，为LCUI_Graph结构体添加auto_attr属性（attr是attribute的缩写），用于指示是否在每次修改图形数据后，自动更新该图形的属性；<br>
				解除每次操作图形时的加锁和解锁操作，因为有时频繁修改图形时，这加锁和解锁的操作，以及图形属性的自动更新，会浪费很多时间。<br>
				队列处理上，也一样，解除每次操作队列时的加锁和解锁操作，需要加锁时直接调用Queue_Lock或Queue_Using函数即可。<br>
				以后需要移植到windows上，那么，如何避免与windows的函数库内的函数同名？例如：RGB函数。<br>
				要么，重新调整函数名，加个LCUI前缀名，再用宏定义，将目前使用简写的函数名替换成原本的函数名，这个以后再考虑，现在懒得纠结。<br>
				其它的功能，在开发过程中再考虑。</p>
				<p>
				有个想法：<br>
				部件的样式能够像html网页那样用css来定义网页元素的样式，贴个示例代码：<br>
				char wnd_css[]= {<br>
				".my_style {"<br>
				"width:320px;"<br>
				"height: 240px;"<br>
				"align:middle-center;"<br>
				"title-text:测试窗口;"<br>
				}<br>
				CSSLib_Add_New( wnd_css );<br>
				Set_Widget_Class( window, "my_style" );<br>
				调用CSSLib_Add_New函数把这个样式载入至样式库，然后调用Set_Widget_Class函数将库中的my_style类样式应用到window部件上。<br>
				CSSLib_Add_New函数是CSSLib模块里的，而Set_Widget_Class函数通过该模块的函数获取相应的样式，并应用到window部件上。<br>
				每种部件应该关联一个函数，用于处理这些样式。</p>
				<h2>2012-12-21</h2>
				<p>整理了一下头文件，部件的源文件和头文件，文件名都改成小写，并去掉LCUI_前缀名，部件的头文件，都转移至include/LCUI/widget/目录下。</p>
				<p>LCUI_Font.h头文件也做了修改，一个头文件包含多个源文件中的函数声明、结构体定义、宏定义，维护起来有点麻烦，我把它缩减了。</p>
				<p>textlayer.c、charset.c、bitmapfont.c等都有自己的头文件，而LCUI_Font.h只是#include这些头文件，它们的头文件都存放在include/LCUI/font/目录下。</p>
				<p>从textlayer.c中分离出了textstyle.c，主要分离了TextStyle相关的结构体和函数，打算再从textlayer.c中分离出文件样式标签处理模块，转移到textstyle.c里。</p>
				<p>git居然能够知道我更改了文件名，不错不错，本以为它会把更名后的文件当新文件对待。</p>
				<h2>2012-12-23</h2>
				<p>圆形边框绘制有点棘手，写了个测试网页，以下是效果图：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-23-16-26-07.png">
					<img class="alignnone" title="圆角绘制" src="http://lcui.org/files/images/devlog/2012-12-23-16-26-07.png"
					alt="" width="133" height="113">
				</a></p>
				<p>div的样式为：“width:100px; height: 100px; border-left:5px solid #000;border-top-left-radius:45px;"<br>
				宽高都为100px，左边框的大小为5px，实线，黑色，左上角的圆角半径为45px。<br>
				从左边框开始，线条逐渐变细，直到上边框的左端为止，这是怎么绘制的？
				</p>
				<p>完成了左上角的圆角绘制，效果如图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-23-20-51-18.png">
					<img class="alignnone" title="测试圆角边框" src="http://lcui.org/files/images/devlog/2012-12-23-20-51-18.png"
					alt="" width="320" height="240">
				</a></p>
				<p>只是绘制线条而已，边框以外的图形并未进行透明处理；这线条并不是连续的，不像一个圆滑的曲线，有锯齿。<br>
				要使绘制出来的线条抗锯齿的话，那就在该点周围添加点，像素点的坐标越是接近计算出来的xy的值，那么，该像素的的颜色越深，反之，越淡。<br>
				说是这样说的，有待继续实验。</p>
				<h2>2012-12-25</h2>
				<p>上图中，从左下角到右上角，点的密度会越来越低，从y轴上看，每一行最多2个点；从x轴上看，有的列却没有一个点。</p>
				<p>圆需要绘制2次，一次是根据y轴计算各点的x轴坐标并填充点，一次是根据x轴计算各点的y轴坐标并填充点；前面一次，每1行最多两个点；而后一次，每1列最多两个点，这样,这些点就能补全整个圆。</p>
				<h2>2012-12-28</h2>
				<p>在实现x轴的各点填充时出现问题，点是乱的，后来发现，是由于没有将double型y轴坐标转换成int型，导致运算结果异常。</p>
				<p>经过一番优化后，已经实现圆的绘制，具体如下图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-28-13-38-14.png">
					<img class="alignnone" title="测试圆的绘制" src="http://lcui.org/files/images/devlog/2012-12-28-13-38-14.png"
					alt="" width="320" height="240">
				</a></p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/blob/06407d48a0b0fda68e80c15a295ff38689e5c26b/src/draw/border.c#L60">可到这里</a>查看圆的绘制代码，其实在绘制1/4圆的同时，就可以绘制剩下的3/4圆。</p>
				<p>接下来就是添加区域有效性处理，绘制的圆可能会超出目标图层的范围，应该确保在绘制圆的时候不超出范围，以避免内存访问越界。</p>
				<p>圆角绘制已经完成，如下图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-28-15-00-00.png">
					<img class="alignnone" title="测试圆角边框的绘制" src="http://lcui.org/files/images/devlog/2012-12-28-15-00-00.png"
					alt="" width="320" height="240">
				</a></p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/blob/c508bd12fde4a9a728a2213976c7aeddf939b88b/src/draw/border.c#L60">这是修改后的代码</a>，圆角边框的线条粗细不能调整，有待完善，圆外的区域透明处理还算比较简单。</p>
				<p>不同粗细的圆角边框线条绘制，可以根据粗细程度，绘制相应数量的圆，例如：线条宽度为5px，那么，需要绘制5个同心圆，它们的半径分别为：5、4、3、2、1，这样就组成了一个线条宽度为5px的圆了。</p>
				<p>自定义线条宽度的圆角绘制已经实现，<a target="_blank" href="https://github.com/lc-soft/LCUI/blob/eccd07e9f7fe22ba2cc4303033b1d511311b712b/src/draw/border.c#L178">可到这里</a>查看修改后的代码，以下是效果图：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-28-15-38-24.png">
					<img class="alignnone" title="测试圆角边框的绘制" src="http://lcui.org/files/images/devlog/2012-12-28-15-38-24.png"
					alt="" width="320" height="240">
				</a></p>
				<p>边框线条宽度为20px，圆角线条里还有一些点没有被填充，看来真的需要实现之前说的那个 圆的抗锯齿处理了。</p>
				<h2>2012-12-30</h2>
				<p>同心圆方法不可行，加了简单的抗锯齿，未填充颜色的点被模糊了，效果不好。</p>
				<h2>2012-12-31</h2>
				<p>改用了另一种方法，这是初始效果图：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-31-13-25-06.png">
					<img class="alignnone" title="新绘制方法的初始效果" src="http://lcui.org/files/images/devlog/2012-12-31-13-25-06.png"
					alt="" width="320" height="240">
				</a></p>
				<p>右半圆比较正常，和之前贴的网页的圆角效果相似，而左半圆有点问题，后来发现是计算公式有问题，纠正后的效果如下图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-31-13-50-44.png">
					<img class="alignnone" title="纠正后的圆的绘制效果" src="http://lcui.org/files/images/devlog/2012-12-31-13-50-44.png"
					alt="" width="320" height="240">
				</a></p>
				<p>可以看出，线条中间部分较细，<a target="_blank" href="https://github.com/lc-soft/LCUI/commit/4eb2e817402e8f169b7fa0e1b73ab17a3e45e792">到这里</a>可查看代码修改情况，但直接绘制线条宽50px、半径为50px的圆，效果有问题，如下图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-31-13-53-19.png">
					<img class="alignnone" title="实心圆的绘制效果" src="http://lcui.org/files/images/devlog/2012-12-31-13-53-19.png"
					alt="" width="320" height="240">
				</a></p>
				<p>还是计算问题，<a target="_blank" href="https://github.com/lc-soft/LCUI/commit/2907fb9540a754808d7e109e0986860f09870aa2">现已纠正</a>，以下是现在的效果：</p>
				<p><a href="http://lcui.org/files/images/devlog/2012-12-31-14-51-54.png">
					<img class="alignnone" title="实心圆的绘制效果" src="http://lcui.org/files/images/devlog/2012-12-31-14-51-54.png"
					alt="" width="320" height="240">
				</a></p>
				<h2>2013-1-1</h2>
				<p>改了一下代码，各个边的圆角化还是分开处理，让圆绘制在有效区域内还真有点麻烦，以下是左上角的绘制效果：</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-01-16-52-31.png">
					<img class="alignnone" title="左上角圆角的绘制效果" src="http://lcui.org/files/images/devlog/2013-01-01-16-52-31.png"
					alt="" width="320" height="240">
				</a></p>
				<p>是不是和之前贴的网页圆角边框绘制效果图一样？只不过浏览器多了抗锯齿处理，<a target="_blank" href="https://github.com/lc-soft/LCUI/blob/90dc1235942c4035aef0df1abeec3b5eaae6566f/src/draw/border.c#L74">可到这里</a>查看修改后的代码，其它角的圆角绘制代码，和这个类似，有待继续添加。</p>
				<p>我也大致能够猜到浏览器是如何绘制网页元素的边框了，4个边框，要绘制8次圆角，就以左上角圆角边框为例：先根据左边框的宽度，确定线条宽度，从左边框的上端开始，到上边框的左端结束，绘制一条圆角线；然后根据上边框的宽度，从上边框的左端开始，到左边框的上端结束，绘制一条圆角线；这种方法，是为了能够在边框各边的尺寸不统一的情况下，也能绘制相应宽度的圆角线。</p>
				
				<h2>2013-1-3</h2>
				<p>完成了左下角和右下角的圆角绘制，代码是复制粘贴左上角和右上角的圆角绘制代码的，只做了一点修改，重复代码较多，以后有空再精简一下，以下是效果图：</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-03-20-11-35.png">
					<img class="alignnone" title="圆角的绘制效果" src="http://lcui.org/files/images/devlog/2013-01-03-20-11-35.png"
					alt="" width="320" height="240">
				</a></p>
				<p>还剩下上左角、上右角、下左角和下右角的，有待继续完善。</p>
				<h2>2013-1-4</h2>
				<p>下左角的圆角绘制存在数据访问越界的问题。</p>
				<p>是计算出了问题，一位坐标超出了范围，已经纠正，以下是目前的效果图：</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-04-18-57-07.png">
					<img class="alignnone" title="圆角的绘制效果" src="http://lcui.org/files/images/devlog/2013-01-04-18-57-07.png"
					alt="" width="320" height="240">
				</a></p>
				<p>需要加入抗锯齿处理，以使圆角润滑。</p>
				<p>有个想法：从LCUI_Widget.c分离出一个模块，名字就这三个：LCUI_Surface.c LCUI_Layer.c LCUI_GraphLayer.c，具体用哪个，有待考虑。反正就是用于处理图层堆叠、显示之类的，而LCUI_Widget.c只用于对widget的图层的位置、尺寸、图形内容等数据进行修改。</p>
				<h2>2013-1-6</h2>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/blob/0de0bd6b7d58f03dbdb70c49d45ed26b51e97a98/test/graph2array.c">写了个图片转代码的程序</a>，之前的图片转代码的程序是windows版的，它是由论坛上的一位网友根据我写的代码写出来的。</p>
				<p>更新了复选框和单选框的图形样式，图形截取自QQ2013的单选框和复选框。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/3420a0927ef651d498853411a071e93eefca8ef9">修改了队列处理模块</a>，对队列的操作不再自动设置锁，需要开发者按需对队列手动设置锁，改了后还没出现什么问题。</p>
				<p>查了一下软考初级成绩，这成绩应该及格了，撸这么久的代码还算没有白撸，下午题的代码，题目说明文字太多，都没仔细看就直接撸代码，幸好还是及格了。</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-06-17-42-52.png">
					<img class="alignnone" title="软考成绩" src="http://lcui.org/files/images/devlog/2013-01-06-17-42-52.png"
					alt="" width="545" height="301">
				</a></p>
				<h2>2013-1-8</h2>
				<p>看了DirectFB源码目录中inputdrivers/keyboard/keyboard.c文件，发现里面的函数都是static的，其中driver_get_available、driver_close_device、driver_get_info这三个函数引起了我的注意，还有开头处的DFB_INPUT_DRIVER( keyboard )这个宏，个人猜测，这三个函数是一个驱动模块必须的函数，由DFB_INPUT_DRIVER宏来注册这个驱动模块。</p>
				<p>keyboard.c的源代码看起来不太困难，没有太多外部模块的函数调用，只需要专注浏览该模块内的代码即可，这就是高内聚低耦合好处，方便了代码阅读，不必在多个模块间切换阅读代码，维护起来也很容易。</p>
				<p>DirectFB的键盘驱动模块是在一个线程上运行的，keyboardEventThread函数中，通过循环读取/dev/tty0设备的数据来获取按键输入，之前看到这段代码：<br>evt.type = ((buf[i] & 0x80) ? DIET_KEYRELEASE : DIET_KEYPRESS);<br>
				本以为它可以判断按键是“按下”状态还是“释放”状态，参考了源代码，自己写了个测试程序，在终端上运行，结果表明的确可以获取按键的状态，可是，按ctrl+alt+F1切换到字符控制台模式后运行它，却只能获取键值，按键状态没法正常获取，一直是0。</p>
				<p>GitHub.com网页有改动，具体如下图所示：</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-08-19-09-30.png">
					<img class="alignnone" title="GitHub新版页面" src="http://lcui.org/files/images/devlog/2013-01-08-19-09-30.png"
					alt="" width="700" height="613">
				</a></p>
				<p>以前是显示直方图以表示项目变动状态，网页改动后，这个图更加直观了，用绿方块表示活跃度，方块颜色越绿，活跃度越高。</p>
				<p>发现BUG，鼠标移动时会有残余图形，刷新区域的添加需要手动对队列上锁，以确保刷新区域的正常添加，已经纠正。</p>
				<h2>2013-1-9</h2>
				<p>需要在src目录下添加kernel目录，分割LCUI_Main.c中的源代码，把分割出来的代码保存至相应新文件里，例如:定时器模块的代码保存至timer.c里。</p>
				<p>部件功能模块需要修改：<br>
				部件状态有normal、disable、hover、active、focus，其中focus状态能和其它状态并存。<br>
				可以为这几种部件状态关联样式类和函数指针，LCUI在处理部件时，会根据关联的样式预先绘制部件，然后，将剩下的工作交给关联的回调函数，对部件进行后期处理。<br>
				这样的话，有些预置部件就只能修改样式，不能修改默认关联的回调函数了,否则部件无法工作。</p>
				<h2>2013-1-10</h2>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/74123ecf1b649c23c3fd8d9fd162320e3b83af73">源代码的分割已经完成</a>，LCUI_Main.c分割成main.c device.c timer.c，并保存在kernel目录，添加了相应头文件，其它源文件和头文件也做了相应修改，LCUI.h中的部分结构体声明做了转移。</p>
				<h2>2013-1-11</h2>
				<p>focus状态就不用了，可通过判断widget的focus属性即可知道该部件是否获得焦点。</p>
				<h2>2013-1-12</h2>
				<p>从LCUI_Widget.c中分离出LCUI_GraphLayer.c模块的话，图层之间的关系需要父图层指针+子图层队列保存，因为图层的容器功能、显示顺序需要队列来记录，而子部件从容器A转移至容器B需要用一个指向父图层的指针，从父图层中的队列中移除子图层记录。而部件之间的父子关系也需要父部件指针+子部件队列保存，部件的鼠标、按键事件的响应需要用到。</p>
				<p>百度搜索时，发现Qt有个函数：widgetAt()，用它可以得到指定点上存在哪个窗口部件，LCUI中同功能的函数是Get_Cursor_Overlay_Widget()，感觉有多余的下划线，函数名太长，可以考虑更名。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/019d45782fa7f98796ee0a157b8dbf3c095018e2">添加了LCUI_GraphLayer.c模块</a>，只设计了一部分函数接口，具体实现代码有待继续编写。</p>
				<h2>2013-1-14</h2>
				<p>正纠结是否需要为LCUI_GraphLayer.c模块添加一个缓冲队列，和widget数据更新处理一样，这是避免频繁因更新数据（坐标、尺寸等）而导致处理耗时变长、数据冗余的问题，举个例子：一个图层要在1秒内从坐标（0，0）匀速移动至坐标（300，0），图层在屏幕上绘制需要时间，而这个时间无法预估，目前的做法是，自己手动确定1秒内更新的帧数，然后计算好每次更新画面时移动的距离，假设为60帧/秒，那么移动速度就是5像素/帧，如果是要让每一帧画面全部显示出来，那么，耗时可能不止1秒，机器配置越低，耗时越长；如果是尽量让该图层的位置移动的耗时接近1秒，那么，需要做“跳帧”处理，若前一次的坐标还未更新，那么这次的新坐标将覆盖前一次。除了坐标外，还有尺寸变更、图形重绘。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/d55b11fe77efa42f755374b9e61a37980a933fc3">做了些修改</a>，结构体中的int型的x、y，改用LCUI_Pos类型,而成员变量z改名为z_index，反正结构体内已经用了LCUI_Graph、LCUI_Queue结构体，再用个LCUI_Pos结构体也无妨。</p>
				<p>LCUI_GraphLayer.c模块应该不需要这个，因为它主要是被LCUI_Widget.c模块调用，而LCUI_Widget.c模块已经实现了数据更新缓冲处理，如果还有其它模块需要使用LCUI_GraphLayer.c模块，且需要考虑上述问题，那到时候再来纠结吧。</p>
				<p>那些3D游戏中的FPS是怎么计算的？如果要我的LCUI实现这个的话，那么就设2个变量：count和fps，分别用于计数和保存FPS，每次对所有部件数据及图形进行更新时，让count自增，再设个定时器，每隔一秒将frame_count赋值给fps，再重置count为0。</p>
				<h2>2013-1-15</h2>
				<p>这是以前提到的simsun.ttc字体的问题：</p>
				<p><a href="http://lcui.org/files/images/devlog/2013-01-15-10-26-11.png">
					<img class="alignnone" title="测试simsun.ttc" src="http://lcui.org/files/images/devlog/2013-01-15-10-26-11.png"
					alt="" width="320" height="240">
				</a></p>
				<p>12px至16px的汉字显示有问题，不知如何解决。</p>
				<p>在写GraphLayer_GetValidRect函数的实现代码时，发现一个问题，图层是否需要添加padding属性支持？不添加该支持的话，虽然用widget可以实现，也就是加个子部件，把所有子部件放进这个子部件，通过调整这个子部件的位置及尺寸，就能实现部件内边距了。但感觉这个有些麻烦，多了几级父子部件关系。</p>
				<p>哦对了，不用部件，用图层就可以了，一个部件有两个图层：A和B，A作为部件主图层，而B作为主图层的子图层，为部件添加子部件，那就直接将子部件的主图层添加至父部件的B图层内，而父子图层关系的解除操作 需要稍微修改一下。</p>
				<p>添加了GraphLayer_GetGraph函数的实现代码以及相关的函数，修改了结构体，<a target="_blank" href="https://github.com/lc-soft/LCUI/blob/a0c9ba92025a71d04908eaf38e51ca981dabe706/src/LCUI_GraphLayer.c">点击这里</a>可查看目前的源代码。</p>
				<h2>2013-1-16</h2>
				<p>写了个测试程序，在测试过程中，发现了一些细节上存在的BUG，现在已经解决，以下是测试程序输出的图片内容：</p>
				<p><a href="http://lcui.org/files/images/devlog/output_graph.png">
					<img class="alignnone" title="output_graph.png" src="http://lcui.org/files/images/devlog/output_graph.png"
					alt="" width="320" height="240">
				</a></p>
				<p>白色的是根图层，图层A是红色，图层B是绿色，图层C是蓝色，图层A和B是根图层的子图层，而图层C是图层B的子图层。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/blob/476b50bd74daec0eb7d370e2a6e4755bc4c5c7b3/test/test_graphlayer.c">点击这里</a>可以查看测试程序的源代码，也可以查看图层的尺寸和坐标。</p>
				<p>接下来就是修改LCUI_Widget.c模块里的代码，改结构体和相关函数代码。</p>
				<h2>2013-1-17</h2>
				<p>纠结了一下，LCUI_GraphLayer不需要记录无效区域，因为图层是在内存中的，图层的位置移动、尺寸改变等，只是改数据，并没改屏幕上显示的内容，没多大关系的东西还是从LCUI_GraphLayer.c模块里分离出去好些。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/85f63ee6e632dab4513bac2c66c67dd91a6e4fd7">修改了一番</a>，已初步完成，能够显示鼠标游标，但不能显示图形界面，有待继续修改。</p>
				<h2>2013-1-18</h2>
				<p>停了一整天的电，用手机看SDL的源代码，在它的html文档中看见union这个词，SDL_Event是个共用体，里面有个type成员变量和其它事件类型结构体，而其它事件类结构体中也有type成员变量，直接对共用体中的type成员变量赋值，该共用体内的其它事件类型的结构体里的type成员变量也会改变，因为它们都是同一块内存空间。</p>
				<p>LCUI的event还是要改一下，各种类型的事件的结构体，改用一个LCUI_Event共用体来包含它们，相关函数需要更名。</p>
				<p>部件的client图层高度有问题，经过一番排查后发现问题原因是 -= 写成了 =，导致client图层高度计算错误。</p>
				<h2>2013-1-19</h2>
				<p>部件图形能正常显示了，还存在一点问题，例如：helloworld程序运行后一直在刷新屏幕区域，理论上显示后，界面没改动就不会更新屏幕区域，应该是哪里出了点问题。</p>
				<p>问题出在Set_Widget_Padding函数，它会调用Update_Widget函数应用这次更新，而window部件的更新处理中，也调用了Set_Widget_Padding函数，就这样一直循环下去。</p>
				<p>看来，应该考虑制定一个规则了：在调用Set_Widget_Padding之类的函数设定部件属性时，需要开发者自己手动调用Update_Widget函数以应用部件属性变化。</p>
				<p>还有一种解决方法，设置部件内边距后，需要调整部件client图层的位置及尺寸，而这个操作在Exec_Update_Widget函数里执行，那么，撤销Set_Widget_Padding函数里的Update_Widget函数调用，把那个调整client图层的代码剪切粘贴到Set_Widget_Padding函数里，这样就Set_Widget_Padding函数就不会调用Update_Widget函数了。</p>
				<p>添加了FPS计算功能，用定时器，每秒更新一次FPS。</p>
				<p>运行 矩形裁剪功能的测试程序，看看FPS是多少，结果，平均FPS在90左右，也发现了部件移动后的区域刷新有问题。</p>
				<h2>2013-1-20</h2>
				<p>区域刷新问题已经解决，原因是没有将内边距计算在内。</p>
				<p>鼠标游标移动至按钮区域内，有一部分区域，移过去后按钮不会高亮，估计是获取指定坐标上的部件时出了点问题，看了代码，问题原因和上面的一样。</p>
				<p>部件的堆叠顺序处理和图层堆叠顺序处理不一致，需要修改。</p>
				<p>鼠标单机子窗口的标题栏时，窗口会向左上方向移动一定距离，需要修改。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/3ec3e50f613970df742c3d4fc6b8328e43dc1b02">纠正了部件的全局坐标 和 坐标转换中存在的计算错误</a>。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/9c878ede3f33e393a8d6b92cd30e1a33d2824f78">部件图层的堆叠顺序问题已经解决</a>，如果图层已经前置，就不会移动它的位置。之前的算法，忽略了图层自己，直接和其它图层对比z_index的值，导致前置图层又被移至它后面的图层的位置上。</p>
				<p>窗口第一次显示时，默认居中显示，由于之前是用Exec_Move_Widget函数直接移动部件位置，而窗口的初始位置更新还在队列中等待处理，导致窗口居中显示后不久位置又变为(0,0)，<a target="_blank" href="https://github.com/lc-soft/LCUI/commit/e730039c280f427eae9ac84a23e2607df3cbf345">改用Move_Widget函数即可</a>。</p>
				<h2>2013-1-22</h2>
				<p>完成了基本的样式字符串的解析功能，有待继续完善。</p>
				<h2>2013-1-23</h2>
				<p>部件更新的处理顺序有问题，本来是先改变部件坐标、后刷新部件区域内的图形显示，处理时却颠倒了顺序，窗口理论上会居中显示，结果，显示时会先显示在左上角，再居中显示。</p>
				<p>做了一次修改，解决窗口第一次显示时不居中显示的问题，之前那个Exec_Move_Widget函数改Move_Widget函数的修改，现在又改回来了，子窗口第一次显示时是居中显示的，但是，在调用Update_Widget_Pos函数时，又把子窗口的位置改为了(0,0)，于是决定修改这个函数的代码，加了个条件：只有在部件对齐方式不为ALIGN_NONE，或者计算的坐标不为(0,0)时才更新部件的位置；部件对齐方式为ALIGN_NONE时，不由LCUI自动更新它的位置，而后面的“计算的坐标不为(0,0)”这个条件，是考虑到部件坐标的单位为百分比的情况。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/blob/master/docs/CodingStyle.zh-cn.md">添加了CodingStyle.zh-cn.md文件</a>，主要描述LCUI目前采用的代码风格，看来还需要修改老代码中的代码风格，比如：LCUI_Widget.c里的代码。</p>
				<h2>2013-1-25</h2>
				<p>准备完善一下事件机制，原先定义的LCUI_Event结构体，主要是用于储存与指定事件关联的回调函数数据，现在更名为LCUI_EventSlot，重新添加新的LCUI_Event结构体，LCUI_Event与LCUI_EventSlot的关系，就像信号（singal）与信号槽（singal slot）。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/61fe2577afb8e2efd7f510cde7cea7dd5783ed01">代码已经初步修改完</a>，需要进一步完善。</p>
				<p>经过一番纠结，决定将EventLoop放在单独的线程上跑，而程序的MainLoop主要用于处理部件的事件，调用已预先注册的回调函数。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/3d4c2d4630ef717bea686be42eac3672810021f4">鼠标的事件处理已经修改</a>，除了拖动部件时有问题外，其余都正常，有待继续完善。</p>
				<p>这么一改，感觉项目的源代码还需要重新规划一下。</p>
				<h2>2013-1-26</h2>
				<p>鼠标事件的修改已经完成，拖动部件移动时，鼠标移动变慢，看来这种方法不行。</p>
				<p>改成以往的方式，用事件和事件槽，鼠标发生移动，就将已注册关联该事件的事件槽中的回调函数，转为任务，添加至任务队列，队列中的同类任务可以被覆盖，这样就能抛弃旧任务去及时处理新的任务。</p>
				<p>这种方式改动较大，应该在添加事件时，对事件队列中已存在的同类未处理事件进行覆盖。</p>
				<p>按上述进行修改，结果，没多大改善。之前是将鼠标的移动事件转为任务添加至程序任务队列，怀疑正常的鼠标移动速度是不是因为任务队列的添加操作导致的，但看了之前的代码，处理鼠标事件时，是直接调用Send_Task_To_App函数将任务追加至任务队列末尾，那么，就排除这个可能了。</p>
				<p>纠结了一番，最后发现是因为鼠标游标位置没有及时更新而导致的，在计算新的鼠标游标位置时，都要调用Get_Cursor_Pos函数获取当前鼠标游标位置，然后加上相对距离，得出新的坐标，但没有及时调用Set_Cursor_Pos函数应用新的坐标，导致下次处理鼠标移动时，获取的函数未更新的游标位置，导致游标移动速度减慢。</p>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/70083b2c2fa3848afcb754b09ca08a3b5f4591d2#L7L130">代码已纠正</a>，主要是将LCUI_HandleMouseMotion函数里的Set_Cursor_Pos函数调用，转移至src/input/mouse.c里的proc_mouse函数中。</p>
				<h2>2013-1-27</h2>
				<p><a target="_blank" href="https://github.com/lc-soft/LCUI/commit/6345fc026035d70f6baf8efdf4dff67c92d9b589">又修改了一番事件机制的代码</a>，与事件关联的回调函数，在处理事件时就会调用，该调用会阻塞整个事件循环。而部件事件的处理，是将回调函数以任务的形式添加至程序任务队列，等待处理。</p>
				<p>与系统相关的事件处理代码，放在event.c里，而与部件相关的事件处理代码，放在LCUI_Work.c里。</p>
				<p>接下来需要完善部件的鼠标事件处理。</p>
				<p>LCUI_Widget结构体需要进行修改。</p>
			</div>
			<!-- Duoshuo Comment BEGIN -->
			<a id="blog-comment">
			</a>
			<div class="ds-thread" data-thread-key="8" data-title="LCUI 0.13.0" data-category="LCUI-Dev"
			data-url="http://www.lcui.org/zh-cn/devlog-lcui-0.13.0.html">
			</div>
			<!-- Duoshuo Comment END -->
			<!-- 网页底部的内容 -->
			<hr>
			<table class="my_style" width="100%">
				<tr>
					<td align="left">
						网页由
						<a href="mailto:lc-soft@live.cn">
							刘超
						</a>
						维护
					</td>
					<td align="right">
						<a target="_blank" href="http://validator.w3.org/check/referer">
							<img border=0 src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.0!"
							height=31 width=88>
						</a>
					</td>
				</tr>
				<tr>
					<td>
						最后更新: 2013-1-26
					</td>
					<td align="right">
						<a target="_blank" href="http://sighttp.qq.com/authd?IDKEY=af7bcac3a71b6cf237e715c4f3beffc6e53bdf1075cb4674">
							<img border="0" src="http://wpa.qq.com/imgd?IDKEY=af7bcac3a71b6cf237e715c4f3beffc6e53bdf1075cb4674&amp;pic=45"
							alt="通过QQ与作者进行交流" title="通过QQ与作者进行交流">
						</a>
						<script type="text/javascript" src="../files/js/baidu-code.js">
						</script>
						<script src="http://s23.cnzz.com/stat.php?id=4262888&amp;web_id=4262888&amp;show=pic1"
						type="text/javascript">
						</script>
					</td>
				</tr>
			</table>
		</div>
	</body>
</html>
<!-- page-front.tpl -->
